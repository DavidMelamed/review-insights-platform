import { prisma } from '../database';
import { logger } from '../utils/logger';
import { BusinessDiscoveryService } from './business-discovery.service';
import { PredictionService } from './prediction.service';
import { DataForSEOService } from './dataforseo.service';
import { WebScrapingService } from './web-scraping.service';
import { AIResponseService } from './ai-response.service';

export interface ZeroConfigSetup {
  businessId: string;
  config: AutoGeneratedConfig;
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  progress: SetupProgress;
  errors?: string[];
  completedAt?: Date;
}

export interface AutoGeneratedConfig {
  business: {
    name: string;
    industry: string;
    description: string;
    website?: string;
    locations?: Location[];
  };
  reviewSources: ReviewSource[];
  competitors: Competitor[];
  monitoring: MonitoringConfig;
  reporting: ReportingConfig;
  integrations: IntegrationConfig[];
  aiSettings: AIConfig;
}

export interface ReviewSource {
  platform: string;
  url: string;
  businessId?: string;
  priority: 'high' | 'medium' | 'low';
  autoDiscovered: boolean;
  lastChecked?: Date;
  reviewCount?: number;
  averageRating?: number;
}

export interface Competitor {
  name: string;
  website?: string;
  reviewSources: ReviewSource[];
  similarity: number; // 0-1 score
  autoDiscovered: boolean;
}

export interface MonitoringConfig {
  frequency: 'realtime' | 'hourly' | 'daily' | 'weekly';
  alerts: AlertConfig[];
  keywords: string[];
  sentimentThresholds: {
    critical: number;
    warning: number;
  };
}

export interface AlertConfig {
  type: 'negative_review' | 'keyword_mention' | 'competitor_mention' | 'volume_spike';
  enabled: boolean;
  threshold?: number;
  channels: string[];
}

export interface ReportingConfig {
  frequency: 'daily' | 'weekly' | 'monthly';
  recipients: string[];
  includeCompetitors: boolean;
  sections: string[];
  format: 'pdf' | 'html' | 'both';
}

export interface IntegrationConfig {
  type: 'slack' | 'email' | 'webhook' | 'zapier' | 'analytics';
  enabled: boolean;
  config: Record<string, any>;
}

export interface AIConfig {
  responseGeneration: {
    enabled: boolean;
    tone: 'professional' | 'friendly' | 'casual';
    autoApprove: boolean;
    templates: ResponseTemplate[];
  };
  insights: {
    enabled: boolean;
    depth: 'basic' | 'detailed' | 'comprehensive';
    focusAreas: string[];
  };
  predictions: {
    enabled: boolean;
    metrics: string[];
  };
}

export interface ResponseTemplate {
  sentiment: 'positive' | 'negative' | 'neutral';
  template: string;
  variables: string[];
}

export interface SetupProgress {
  currentStep: string;
  completedSteps: string[];
  totalSteps: number;
  percentComplete: number;
  estimatedTimeRemaining?: number; // seconds
}

export interface Location {
  address: string;
  city: string;
  state?: string;
  country: string;
  coordinates?: {
    lat: number;
    lng: number;
  };
}

export class ZeroConfigService {
  private discoveryService: BusinessDiscoveryService;
  private predictionService: PredictionService;
  private dataForSEOService: DataForSEOService;
  private scrapingService: WebScrapingService;
  private aiService: AIResponseService;

  constructor() {
    this.discoveryService = new BusinessDiscoveryService();
    this.predictionService = new PredictionService();
    this.dataForSEOService = new DataForSEOService(process.env.DATAFORSEO_API_KEY!);
    this.scrapingService = new WebScrapingService();
    this.aiService = new AIResponseService();
  }

  async setupBusiness(identifier: string, userId: string): Promise<ZeroConfigSetup> {
    try {
      logger.info('Starting zero-config setup', { identifier, userId });

      const setupId = this.generateSetupId();
      const setup: ZeroConfigSetup = {
        businessId: setupId,
        config: await this.generateInitialConfig(),
        status: 'in_progress',
        progress: {
          currentStep: 'discovery',
          completedSteps: [],
          totalSteps: 8,
          percentComplete: 0,
        },
      };

      // Save initial setup
      await this.saveSetup(setup, userId);

      // Start async setup process
      this.performSetup(setup, identifier, userId).catch(error => {
        logger.error('Setup process failed', { error, setupId });
      });

      return setup;
    } catch (error) {
      logger.error('Failed to start zero-config setup', { error, identifier });
      throw error;
    }
  }

  private async performSetup(
    setup: ZeroConfigSetup,
    identifier: string,
    userId: string
  ): Promise<void> {
    const steps = [
      { name: 'discovery', fn: () => this.stepDiscoverBusiness(setup, identifier) },
      { name: 'competitors', fn: () => this.stepFindCompetitors(setup) },
      { name: 'sources', fn: () => this.stepDiscoverReviewSources(setup) },
      { name: 'monitoring', fn: () => this.stepConfigureMonitoring(setup) },
      { name: 'reporting', fn: () => this.stepConfigureReporting(setup) },
      { name: 'integrations', fn: () => this.stepSetupIntegrations(setup) },
      { name: 'ai', fn: () => this.stepConfigureAI(setup) },
      { name: 'finalize', fn: () => this.stepFinalize(setup, userId) },
    ];

    for (let i = 0; i < steps.length; i++) {
      const step = steps[i];
      try {
        setup.progress.currentStep = step.name;
        setup.progress.percentComplete = Math.round((i / steps.length) * 100);
        await this.updateSetup(setup);

        await step.fn();

        setup.progress.completedSteps.push(step.name);
        setup.progress.percentComplete = Math.round(((i + 1) / steps.length) * 100);
        await this.updateSetup(setup);
      } catch (error) {
        logger.error(`Setup step failed: ${step.name}`, { error, setupId: setup.businessId });
        setup.status = 'failed';
        setup.errors = [...(setup.errors || []), `Failed at step: ${step.name}`];
        await this.updateSetup(setup);
        throw error;
      }
    }

    setup.status = 'completed';
    setup.completedAt = new Date();
    await this.updateSetup(setup);
  }

  private async stepDiscoverBusiness(setup: ZeroConfigSetup, identifier: string): Promise<void> {
    // Discover business information
    const discovered = await this.discoveryService.discover(identifier);
    
    setup.config.business = {
      name: discovered.businessName,
      industry: discovered.industry,
      description: discovered.description || '',
      website: discovered.website,
      locations: discovered.locations?.map(loc => ({
        address: loc.address,
        city: loc.city,
        state: loc.state,
        country: loc.country || 'USA',
        coordinates: loc.coordinates,
      })),
    };

    logger.info('Business discovered', { business: setup.config.business });
  }

  private async stepFindCompetitors(setup: ZeroConfigSetup): Promise<void> {
    const { business } = setup.config;
    
    // Find competitors using multiple methods
    const competitors: Competitor[] = [];

    // 1. Search engines for similar businesses
    const searchResults = await this.searchForCompetitors(business.name, business.industry);
    
    // 2. Industry databases
    const industryCompetitors = await this.getIndustryCompetitors(business.industry, business.locations?.[0]?.city);
    
    // 3. Review platforms for nearby similar businesses
    const nearbyCompetitors = await this.findNearbyCompetitors(business);

    // Merge and deduplicate
    const allCompetitors = [...searchResults, ...industryCompetitors, ...nearbyCompetitors];
    const uniqueCompetitors = this.deduplicateCompetitors(allCompetitors);

    // Score and rank competitors
    setup.config.competitors = await Promise.all(
      uniqueCompetitors.slice(0, 10).map(async comp => ({
        ...comp,
        similarity: await this.calculateSimilarity(business, comp),
        reviewSources: await this.discoverCompetitorReviewSources(comp),
      }))
    );

    logger.info('Competitors found', { count: setup.config.competitors.length });
  }

  private async stepDiscoverReviewSources(setup: ZeroConfigSetup): Promise<void> {
    const { business } = setup.config;
    const sources: ReviewSource[] = [];

    // Common review platforms to check
    const platforms = [
      { name: 'Google', searcher: this.findGoogleBusiness },
      { name: 'Yelp', searcher: this.findYelpBusiness },
      { name: 'Trustpilot', searcher: this.findTrustpilotBusiness },
      { name: 'Facebook', searcher: this.findFacebookBusiness },
      { name: 'TripAdvisor', searcher: this.findTripAdvisorBusiness },
      { name: 'G2', searcher: this.findG2Business },
      { name: 'Capterra', searcher: this.findCapterraBusiness },
      { name: 'Amazon', searcher: this.findAmazonBusiness },
    ];

    // Industry-specific platforms
    const industryPlatforms = this.getIndustrySpecificPlatforms(business.industry);
    platforms.push(...industryPlatforms);

    // Search each platform
    for (const platform of platforms) {
      try {
        const result = await platform.searcher.call(this, business);
        if (result) {
          sources.push({
            platform: platform.name,
            url: result.url,
            businessId: result.id,
            priority: this.calculateSourcePriority(result),
            autoDiscovered: true,
            reviewCount: result.reviewCount,
            averageRating: result.rating,
          });
        }
      } catch (error) {
        logger.warn(`Failed to search ${platform.name}`, { error });
      }
    }

    // Sort by priority
    setup.config.reviewSources = sources.sort((a, b) => {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });

    logger.info('Review sources discovered', { count: sources.length });
  }

  private async stepConfigureMonitoring(setup: ZeroConfigSetup): Promise<void> {
    const { business, reviewSources } = setup.config;
    
    // Predict monitoring needs
    const predictions = await this.predictionService.predictBusinessNeeds({
      businessName: business.name,
      industry: business.industry,
      website: business.website,
    });

    // Determine monitoring frequency based on review volume
    const totalReviews = reviewSources.reduce((sum, source) => sum + (source.reviewCount || 0), 0);
    const frequency = this.determineMonitoringFrequency(totalReviews, business.industry);

    // Set up alerts based on industry standards
    const alerts = this.getIndustryAlerts(business.industry);

    // Extract keywords from business description and industry
    const keywords = await this.extractMonitoringKeywords(business);

    setup.config.monitoring = {
      frequency,
      alerts,
      keywords,
      sentimentThresholds: {
        critical: -0.5,
        warning: -0.2,
      },
    };

    logger.info('Monitoring configured', { frequency, alertsCount: alerts.length });
  }

  private async stepConfigureReporting(setup: ZeroConfigSetup): Promise<void> {
    const { business } = setup.config;
    
    // Determine reporting frequency based on business type
    const frequency = this.getReportingFrequency(business.industry);
    
    // Select report sections based on industry
    const sections = this.getIndustryReportSections(business.industry);

    setup.config.reporting = {
      frequency,
      recipients: [], // Will be filled during user confirmation
      includeCompetitors: true,
      sections,
      format: 'both',
    };

    logger.info('Reporting configured', { frequency, sections });
  }

  private async stepSetupIntegrations(setup: ZeroConfigSetup): Promise<void> {
    const integrations: IntegrationConfig[] = [];

    // Always set up email integration
    integrations.push({
      type: 'email',
      enabled: true,
      config: {
        provider: 'sendgrid',
        templates: {
          alert: 'default-alert',
          report: 'default-report',
        },
      },
    });

    // Set up webhook for extensibility
    integrations.push({
      type: 'webhook',
      enabled: true,
      config: {
        url: '', // To be configured by user
        events: ['review.new', 'alert.triggered', 'report.generated'],
      },
    });

    // Analytics integration
    integrations.push({
      type: 'analytics',
      enabled: true,
      config: {
        provider: 'mixpanel',
        events: ['review_received', 'alert_sent', 'report_viewed'],
      },
    });

    setup.config.integrations = integrations;
    logger.info('Integrations configured', { count: integrations.length });
  }

  private async stepConfigureAI(setup: ZeroConfigSetup): Promise<void> {
    const { business } = setup.config;
    
    // Determine AI tone based on industry
    const tone = this.getIndustryTone(business.industry);
    
    // Create response templates
    const templates = this.generateResponseTemplates(business.industry);
    
    // Configure insights based on business size
    const insightsDepth = this.determineInsightsDepth(setup.config.reviewSources);
    
    // Select prediction metrics
    const predictionMetrics = this.getIndustryPredictionMetrics(business.industry);

    setup.config.aiSettings = {
      responseGeneration: {
        enabled: true,
        tone,
        autoApprove: false, // Always require approval initially
        templates,
      },
      insights: {
        enabled: true,
        depth: insightsDepth,
        focusAreas: this.getIndustryFocusAreas(business.industry),
      },
      predictions: {
        enabled: true,
        metrics: predictionMetrics,
      },
    };

    logger.info('AI settings configured', { tone, insightsDepth });
  }

  private async stepFinalize(setup: ZeroConfigSetup, userId: string): Promise<void> {
    // Create user account with discovered settings
    const user = await prisma.user.create({
      data: {
        id: userId,
        email: '', // To be filled by user
        subscription: {
          create: {
            plan: 'PROFESSIONAL', // Start with professional trial
            status: 'TRIAL',
            currentPeriodEnd: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000), // 14-day trial
          },
        },
      },
    });

    // Save configuration
    await prisma.usageRecord.create({
      data: {
        userId,
        action: 'zero_config_setup',
        credits: 0,
        metadata: setup.config as any,
      },
    });

    // Start initial data collection
    await this.startInitialCollection(setup.config, userId);

    logger.info('Setup finalized', { userId });
  }

  // Helper methods
  private async searchForCompetitors(businessName: string, industry: string): Promise<Competitor[]> {
    // Implementation would use search APIs
    return [];
  }

  private async getIndustryCompetitors(industry: string, location?: string): Promise<Competitor[]> {
    // Implementation would query industry databases
    return [];
  }

  private async findNearbyCompetitors(business: any): Promise<Competitor[]> {
    // Implementation would use location-based search
    return [];
  }

  private deduplicateCompetitors(competitors: Competitor[]): Competitor[] {
    const seen = new Set<string>();
    return competitors.filter(comp => {
      const key = comp.name.toLowerCase().replace(/\s+/g, '');
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }

  private async calculateSimilarity(business: any, competitor: Competitor): Promise<number> {
    // Implement similarity scoring based on industry, size, location, etc.
    return Math.random() * 0.5 + 0.5; // Placeholder
  }

  private async discoverCompetitorReviewSources(competitor: Competitor): Promise<ReviewSource[]> {
    // Implementation would search for competitor on review platforms
    return [];
  }

  private getIndustrySpecificPlatforms(industry: string): any[] {
    const platformMap: Record<string, any[]> = {
      'Restaurant': [
        { name: 'OpenTable', searcher: this.findOpenTableBusiness },
        { name: 'Zomato', searcher: this.findZomatoBusiness },
      ],
      'Hotel': [
        { name: 'Booking.com', searcher: this.findBookingBusiness },
        { name: 'Hotels.com', searcher: this.findHotelsBusiness },
      ],
      'Healthcare': [
        { name: 'Healthgrades', searcher: this.findHealthgradesBusiness },
        { name: 'Vitals', searcher: this.findVitalsBusiness },
      ],
      'Automotive': [
        { name: 'Cars.com', searcher: this.findCarsBusiness },
        { name: 'DealerRater', searcher: this.findDealerRaterBusiness },
      ],
    };

    return platformMap[industry] || [];
  }

  private calculateSourcePriority(result: any): 'high' | 'medium' | 'low' {
    if (result.reviewCount > 100) return 'high';
    if (result.reviewCount > 20) return 'medium';
    return 'low';
  }

  private determineMonitoringFrequency(totalReviews: number, industry: string): MonitoringConfig['frequency'] {
    if (totalReviews > 1000 || ['Restaurant', 'Hotel'].includes(industry)) {
      return 'realtime';
    }
    if (totalReviews > 100) return 'hourly';
    if (totalReviews > 20) return 'daily';
    return 'weekly';
  }

  private getIndustryAlerts(industry: string): AlertConfig[] {
    const baseAlerts: AlertConfig[] = [
      {
        type: 'negative_review',
        enabled: true,
        threshold: 2, // 2 stars or below
        channels: ['email', 'slack'],
      },
      {
        type: 'keyword_mention',
        enabled: true,
        channels: ['email'],
      },
    ];

    // Add industry-specific alerts
    if (['Restaurant', 'Hotel'].includes(industry)) {
      baseAlerts.push({
        type: 'volume_spike',
        enabled: true,
        threshold: 150, // 150% of normal
        channels: ['email', 'slack'],
      });
    }

    return baseAlerts;
  }

  private async extractMonitoringKeywords(business: any): Promise<string[]> {
    const keywords = [business.name];
    
    // Add industry-specific keywords
    const industryKeywords: Record<string, string[]> = {
      'Restaurant': ['food poisoning', 'wait time', 'reservation', 'menu'],
      'Hotel': ['bedbugs', 'cleanliness', 'wifi', 'check-in'],
      'E-commerce': ['shipping', 'refund', 'scam', 'quality'],
      'Healthcare': ['malpractice', 'insurance', 'appointment', 'staff'],
    };

    keywords.push(...(industryKeywords[business.industry] || []));
    
    return keywords;
  }

  private getReportingFrequency(industry: string): ReportingConfig['frequency'] {
    const highFrequencyIndustries = ['Restaurant', 'Hotel', 'E-commerce'];
    return highFrequencyIndustries.includes(industry) ? 'weekly' : 'monthly';
  }

  private getIndustryReportSections(industry: string): string[] {
    const baseSections = [
      'executive_summary',
      'rating_trends',
      'sentiment_analysis',
      'top_complaints',
      'competitor_comparison',
    ];

    const industrySections: Record<string, string[]> = {
      'Restaurant': ['menu_feedback', 'service_analysis', 'ambiance_mentions'],
      'Hotel': ['room_feedback', 'amenities_analysis', 'location_mentions'],
      'E-commerce': ['product_quality', 'shipping_analysis', 'customer_service'],
      'Healthcare': ['wait_times', 'staff_feedback', 'treatment_outcomes'],
    };

    return [...baseSections, ...(industrySections[industry] || [])];
  }

  private getIndustryTone(industry: string): AIConfig['responseGeneration']['tone'] {
    const professionalIndustries = ['Healthcare', 'Finance', 'Legal'];
    const casualIndustries = ['Restaurant', 'Entertainment', 'Fitness'];
    
    if (professionalIndustries.includes(industry)) return 'professional';
    if (casualIndustries.includes(industry)) return 'casual';
    return 'friendly';
  }

  private generateResponseTemplates(industry: string): ResponseTemplate[] {
    // Generate industry-specific templates
    return [
      {
        sentiment: 'positive',
        template: 'Thank you for your wonderful review, {customerName}! We\'re thrilled to hear about your positive experience with {aspectMentioned}. Your feedback means the world to us!',
        variables: ['customerName', 'aspectMentioned'],
      },
      {
        sentiment: 'negative',
        template: 'We sincerely apologize for your experience, {customerName}. Your feedback about {issue} is valuable, and we\'d like to make this right. Please contact us at {contactInfo} so we can resolve this.',
        variables: ['customerName', 'issue', 'contactInfo'],
      },
      {
        sentiment: 'neutral',
        template: 'Thank you for taking the time to share your feedback, {customerName}. We appreciate your insights about {aspectMentioned} and will use them to improve our service.',
        variables: ['customerName', 'aspectMentioned'],
      },
    ];
  }

  private determineInsightsDepth(reviewSources: ReviewSource[]): AIConfig['insights']['depth'] {
    const totalReviews = reviewSources.reduce((sum, source) => sum + (source.reviewCount || 0), 0);
    
    if (totalReviews > 1000) return 'comprehensive';
    if (totalReviews > 100) return 'detailed';
    return 'basic';
  }

  private getIndustryFocusAreas(industry: string): string[] {
    const focusAreaMap: Record<string, string[]> = {
      'Restaurant': ['food_quality', 'service', 'ambiance', 'value', 'cleanliness'],
      'Hotel': ['room_quality', 'service', 'location', 'amenities', 'cleanliness'],
      'E-commerce': ['product_quality', 'shipping', 'customer_service', 'pricing', 'returns'],
      'Healthcare': ['care_quality', 'wait_times', 'staff', 'communication', 'billing'],
      'SaaS': ['features', 'usability', 'support', 'pricing', 'reliability'],
    };

    return focusAreaMap[industry] || ['quality', 'service', 'value', 'experience'];
  }

  private getIndustryPredictionMetrics(industry: string): string[] {
    const baseMetrics = ['rating_trend', 'review_volume', 'sentiment_trend'];
    
    const industryMetrics: Record<string, string[]> = {
      'Restaurant': ['seasonal_trends', 'menu_performance'],
      'Hotel': ['occupancy_correlation', 'seasonal_demand'],
      'E-commerce': ['product_lifecycle', 'return_rate_prediction'],
      'SaaS': ['churn_prediction', 'feature_adoption'],
    };

    return [...baseMetrics, ...(industryMetrics[industry] || [])];
  }

  private async startInitialCollection(config: AutoGeneratedConfig, userId: string): Promise<void> {
    // Queue initial review collection for all discovered sources
    for (const source of config.reviewSources) {
      await prisma.collectionTask.create({
        data: {
          userId,
          source: source.platform,
          url: source.url,
          status: 'PENDING',
          priority: source.priority === 'high' ? 1 : source.priority === 'medium' ? 2 : 3,
        },
      });
    }

    logger.info('Initial collection queued', { sources: config.reviewSources.length });
  }

  // Platform searcher methods (stubs)
  private async findGoogleBusiness(business: any): Promise<any> {
    // Implementation would use Google Places API
    return null;
  }

  private async findYelpBusiness(business: any): Promise<any> {
    // Implementation would use Yelp API
    return null;
  }

  private async findTrustpilotBusiness(business: any): Promise<any> {
    // Implementation would search Trustpilot
    return null;
  }

  private async findFacebookBusiness(business: any): Promise<any> {
    // Implementation would use Facebook Graph API
    return null;
  }

  private async findTripAdvisorBusiness(business: any): Promise<any> {
    // Implementation would search TripAdvisor
    return null;
  }

  private async findG2Business(business: any): Promise<any> {
    // Implementation would search G2
    return null;
  }

  private async findCapterraBusiness(business: any): Promise<any> {
    // Implementation would search Capterra
    return null;
  }

  private async findAmazonBusiness(business: any): Promise<any> {
    // Implementation would search Amazon
    return null;
  }

  private async findOpenTableBusiness(business: any): Promise<any> {
    // Implementation would search OpenTable
    return null;
  }

  private async findZomatoBusiness(business: any): Promise<any> {
    // Implementation would search Zomato
    return null;
  }

  private async findBookingBusiness(business: any): Promise<any> {
    // Implementation would search Booking.com
    return null;
  }

  private async findHotelsBusiness(business: any): Promise<any> {
    // Implementation would search Hotels.com
    return null;
  }

  private async findHealthgradesBusiness(business: any): Promise<any> {
    // Implementation would search Healthgrades
    return null;
  }

  private async findVitalsBusiness(business: any): Promise<any> {
    // Implementation would search Vitals
    return null;
  }

  private async findCarsBusiness(business: any): Promise<any> {
    // Implementation would search Cars.com
    return null;
  }

  private async findDealerRaterBusiness(business: any): Promise<any> {
    // Implementation would search DealerRater
    return null;
  }

  // Utility methods
  private generateSetupId(): string {
    return `setup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private async generateInitialConfig(): Promise<AutoGeneratedConfig> {
    return {
      business: {
        name: '',
        industry: '',
        description: '',
      },
      reviewSources: [],
      competitors: [],
      monitoring: {
        frequency: 'daily',
        alerts: [],
        keywords: [],
        sentimentThresholds: {
          critical: -0.5,
          warning: -0.2,
        },
      },
      reporting: {
        frequency: 'weekly',
        recipients: [],
        includeCompetitors: true,
        sections: [],
        format: 'both',
      },
      integrations: [],
      aiSettings: {
        responseGeneration: {
          enabled: true,
          tone: 'friendly',
          autoApprove: false,
          templates: [],
        },
        insights: {
          enabled: true,
          depth: 'detailed',
          focusAreas: [],
        },
        predictions: {
          enabled: true,
          metrics: [],
        },
      },
    };
  }

  private async saveSetup(setup: ZeroConfigSetup, userId: string): Promise<void> {
    // Save to database
    await prisma.usageRecord.create({
      data: {
        userId,
        action: 'zero_config_progress',
        credits: 0,
        metadata: setup as any,
      },
    });
  }

  private async updateSetup(setup: ZeroConfigSetup): Promise<void> {
    // Update in database
    logger.debug('Setup progress updated', {
      setupId: setup.businessId,
      step: setup.progress.currentStep,
      percent: setup.progress.percentComplete,
    });
  }
}